# DESCRIPTION:
#
# Executes shor's algorithm using the pbit module. We should should see peaks at 0 and 8, which are ideally 0.5 high.
# This method follows a post-processing approach, in which all the samples are first generated by the gpu, providing the
# magnitude for the qubits we are trying to model. The phase of each qubit is then calculated in post-processing via the
# cmath.phase function. Depending on the phase of each p-circuit state, the state may interfere constructively or
# destructively with the existing sum. This interference eventually reveals the correct peaks.

# Authors: Python code: Anirudh Ghantasala, MATLAB code and concepts, Shuvro Chowdhury



import scipy.io
import numpy as np
import cmath
import pbit
import matplotlib.pyplot as plt


# these values taken from matlab file python_helper_isingshor.m which uses shuvro's IsingGraphShor2.m
mat = scipy.io.loadmat('JH_MATLAB.mat')
J, h, Jr, hr, es, Prefac = mat['J'], mat['h'], mat['Jr'], mat['hr'], mat['es'], mat['Prefac']
betaPSL = 1
Nm = len(h)
Nt = 1000000
numTotal_qbits = 5

print('Building Network...')
myp = pbit.pcircuit(Jr, hr)
myp.draw()
print('Generating samples...')
m_all = myp.generate_samples(Nt, gpu=True)
m_all[m_all == 0] = -1

Probs = np.zeros(2 ** numTotal_qbits, dtype=np.complex_)
E = complex(0, 0)
m = np.sign(np.add(np.random.rand(Nm) * 2, -1))
print('Post-processing...')
for i in range(Nt):
    m = m_all[i, :]
    E = es + np.multiply(0.5, np.dot(np.dot(m, J), m)) + np.dot(np.expand_dims(m, 0), h)
    phi = cmath.phase(np.exp(-1 * betaPSL * E))
    X2 = pbit.bi_arr2de(m[[19, 16, 13, 10, 23]])
    Probs[X2] = Probs[X2] + np.exp(1j * phi)


# now we have results, just need to plot
Probs2 = np.multiply(Probs, Prefac)[0]
PSL = np.divide(Probs2, np.sqrt(np.sum(np.square(np.abs(Probs2)))))[1:31:2]
XX = np.square(np.abs(PSL))
xrange = np.arange(15)
print('Complete...')
plt.stem(xrange, XX, use_line_collection=True)
plt.show()




